{"version":3,"file":"auth.service.js","sourceRoot":"","sources":["../../../../src/api/auth/service/auth.service.ts"],"names":[],"mappings":";;;;;;AAAA,wDAA8B;AAG9B,4FAAmE;AACnE,mEAA+D;AAE/D,MAAa,eAAe;IACT,gBAAgB,CAAkB;IACnD,YAAY,eAAgC;QAC1C,IAAI,CAAC,gBAAgB,GAAG,eAAe,CAAC;IAC1C,CAAC;IAED,KAAK,CAAC,KAAK,CACT,KAAa,EACb,QAAgB;QAEhB,IAAI,SAAS,GAAG,MAAM,IAAI,CAAC,gBAAgB,CAAC,WAAW,CAAC,KAAK,CAAC,CAAC;QAC/D,OAAO,CAAC,GAAG,CAAC,SAAS,CAAC,CAAC;QACvB,IAAI,CAAC,SAAS,EAAE,CAAC;YACf,MAAM,IAAI,wBAAa,CAAC,GAAG,EAAE,gBAAgB,CAAC,CAAC;QACjD,CAAC;QAED,MAAM,aAAa,GAAG,QAAQ,CAAC,CAAC,yBAAyB;QACzD,MAAM,cAAc,GAAG,SAAS,CAAC,QAAQ,CAAC,CAAC,wBAAwB;QAEnE,MAAM,cAAc,GAAG,MAAM,kBAAM,CAAC,OAAO,CAAC,aAAa,EAAE,cAAc,CAAC,CAAC;QAE3E,IAAI,CAAC,cAAc,EAAE,CAAC;YACpB,MAAM,IAAI,wBAAa,CAAC,GAAG,EAAE,kBAAkB,CAAC,CAAC;QACnD,CAAC;QAED,MAAM,WAAW,GAAG,wBAAU,CAAC,mBAAmB,CAAC;YACjD,EAAE,EAAE,SAAS,CAAC,EAAE;YAChB,IAAI,EAAE,SAAS,CAAC,IAAI;YACpB,SAAS,EAAE,IAAI;SAChB,CAAC,CAAC;QACH,OAAO,CAAC,GAAG,CAAC,WAAW,CAAC,CAAC;QAEzB,OAAO,EAAE,WAAW,EAAE,IAAI,EAAE,SAAS,EAAE,CAAC;IAC1C,CAAC;IAED,KAAK,CAAC,MAAM,KAAmB,CAAC;CACjC;AApCD,0CAoCC","sourcesContent":["import bcrypt from \"bcryptjs\";\nimport { AuthService } from \"@/api/auth/service/auth.service.type\";\nimport { AdminRepository } from \"@/api/admin/repository/admin.repository\";\nimport HttpException from \"@/api/common/exceptions/http.exception\";\nimport { JwtService } from \"@/api/common/services/jwt.service\";\n\nexport class AuthServiceImpl implements AuthService {\n  private readonly _adminRepository: AdminRepository;\n  constructor(adminRepository: AdminRepository) {\n    this._adminRepository = adminRepository;\n  }\n\n  async login(\n    email: string,\n    password: string\n  ): Promise<{ accessToken: string; user: IAdmin }> {\n    let findEmail = await this._adminRepository.findByEmail(email);\n    console.log(findEmail);\n    if (!findEmail) {\n      throw new HttpException(404, \"존재하지 않는 회원입니다.\");\n    }\n\n    const plainPassword = password; // 사용자가 입력한 비밀번호 (일반 텍스트)\n    const hashedPassword = findEmail.password; // 데이터베이스에서 가져온 해싱된 비밀번호\n\n    const isSamePassword = await bcrypt.compare(plainPassword, hashedPassword);\n\n    if (!isSamePassword) {\n      throw new HttpException(401, \"비밀번호가 일치하지 않습니다.\");\n    }\n\n    const accessToken = JwtService.generateAccessToken({\n      id: findEmail.id,\n      role: findEmail.role,\n      expiresIn: \"1h\",\n    });\n    console.log(accessToken);\n\n    return { accessToken, user: findEmail };\n  }\n\n  async logout(): Promise<void> {}\n}\n"]}